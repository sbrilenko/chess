"use strict"; function GetFen() { for (var n = "", t, r, u, f, i = 0; i < 8; i++) { for (i != 0 && (n += "/"), t = 0, r = 0; r < 8; r++) u = g_board[(i + 2 << 4) + r + 4], u == 0 ? t++ : (t != 0 && (n += t), t = 0, f = [" ", "p", "n", "b", "r", "q", "k", " "][u & 7], n += (u & colorWhite) != 0 ? f.toUpperCase() : f); t != 0 && (n += t) } return n += g_toMove == colorWhite ? " w" : " b", n += " ", g_castleRights == 0 ? n += "-" : ((g_castleRights & 1) != 0 && (n += "K"), (g_castleRights & 2) != 0 && (n += "Q"), (g_castleRights & 4) != 0 && (n += "k"), (g_castleRights & 8) != 0 && (n += "q")), n += " ", n + (g_enPassentSquare == -1 ? "-" : FormatSquare(g_enPassentSquare)) } function GetMoveSAN(n, t) { var i = n & 255, e = n >> 8 & 255, u, f, l; if (n & moveflagCastleKing) return "O-O"; if (n & moveflagCastleQueen) return "O-O-O"; var o = g_board[i] & 7, r = ["", "", "N", "B", "R", "Q", "K", ""][o], s = !1, h = !0, c = !0; for (t == null && (t = GenerateValidMoves()), u = 0; u < t.length; u++) f = t[u] & 255, l = t[u] >> 8 & 255, f != i && l == e && (g_board[f] & 7) == o && (s = !0, (f & 240) == (i & 240) && (h = !1), (f & 15) == (i & 15) && (c = !1)); return s ? r += c ? FormatSquare(i).charAt(0) : h ? FormatSquare(i).charAt(1) : FormatSquare(i) : o == piecePawn && (g_board[e] != 0 || n & moveflagEPC) && (r += FormatSquare(i).charAt(0)), (g_board[e] != 0 || n & moveflagEPC) && (r += "x"), r += FormatSquare(e), n & moveflagPromotion && (r += n & moveflagPromoteBishop ? "=B" : n & moveflagPromoteKnight ? "=N" : n & moveflagPromoteQueen ? "=Q" : "=R"), MakeMove(n), g_inCheck && (r += GenerateValidMoves().length == 0 ? "#" : "+"), UnmakeMove(n), r } function FormatSquare(n) { return ["a", "b", "c", "d", "e", "f", "g", "h"][(n & 15) - 4] + (10 - (n >> 4)) } function FormatMove(n) { var t = FormatSquare(n & 255) + FormatSquare(n >> 8 & 255); return n & moveflagPromotion && (t += n & moveflagPromoteBishop ? "b" : n & moveflagPromoteKnight ? "n" : n & moveflagPromoteQueen ? "q" : "r"), t } function GetMoveFromString(n) { for (var i = GenerateValidMoves(), t = 0; t < i.length; t++) if (FormatMove(i[t]) == n) return i[t]; } function PVFromHash(n, t) { var r, i; return t == 0 ? "" : n == 0 ? g_inCheck ? "checkmate" : "stalemate" : (r = " " + GetMoveSAN(n), MakeMove(n), i = g_hashTable[g_hashKeyLow & g_hashMask], i != null && i.lock == g_hashKeyHigh && i.bestMove != null && (r += PVFromHash(i.bestMove, t - 1)), UnmakeMove(n), r) } function Search(n, t, i) { var r = minEval, e = maxEval, o, u, f, s; for (g_globalPly++, g_nodeCount = 0, g_qNodeCount = 0, g_searchValid = !0, o = 0, g_startTime = (new Date).getTime(), f = 1; f <= t && g_searchValid; f++) { if (s = AlphaBeta(f, 0, r, e), !g_searchValid) break; u = s; u > r && u < e ? (r = u - 500, e = u + 500, r < minEval && (r = minEval), e > maxEval && (e = maxEval)) : r != minEval && (r = minEval, e = maxEval, f--); g_hashTable[g_hashKeyLow & g_hashMask] != null && (o = g_hashTable[g_hashKeyLow & g_hashMask].bestMove); i != null && i(o, u, (new Date).getTime() - g_startTime, f) } n != null && n(o, u, (new Date).getTime() - g_startTime, f - 1) } function PawnEval(n) { for (var t = (n | 1) << 4, i = g_pieceList[t++]; i != 0;) i = g_pieceList[t++] } function Mobility(n) { var o = 0, r, t, i, f, u = n == 8 ? 16 : 8, e = n == 8 ? g_mobUnit[0] : g_mobUnit[1]; for (i = -3, f = (n | 2) << 4, r = g_pieceList[f++]; r != 0;) i += e[g_board[r + 31]], i += e[g_board[r + 33]], i += e[g_board[r + 14]], i += e[g_board[r - 14]], i += e[g_board[r - 31]], i += e[g_board[r - 33]], i += e[g_board[r + 18]], i += e[g_board[r - 18]], r = g_pieceList[f++]; for (o += 65 * i, i = -4, f = (n | 3) << 4, r = g_pieceList[f++]; r != 0;) { for (t = r - 15; g_board[t] == 0;) t -= 15, i++; if (g_board[t] & u && (i++, !(g_board[t] & piecePawn))) { for (t -= 15; g_board[t] == 0;) t -= 15; i += e[g_board[t]] << 2 } for (t = r - 17; g_board[t] == 0;) t -= 17, i++; if (g_board[t] & u && (i++, !(g_board[t] & piecePawn))) { for (t -= 17; g_board[t] == 0;) t -= 17; i += e[g_board[t]] << 2 } for (t = r + 15; g_board[t] == 0;) t += 15, i++; if (g_board[t] & u && (i++, !(g_board[t] & piecePawn))) { for (t += 15; g_board[t] == 0;) t += 15; i += e[g_board[t]] << 2 } for (t = r + 17; g_board[t] == 0;) t += 17, i++; if (g_board[t] & u && (i++, !(g_board[t] & piecePawn))) { for (t += 17; g_board[t] == 0;) t += 17; i += e[g_board[t]] << 2 } r = g_pieceList[f++] } for (o += 44 * i, i = -4, f = (n | 4) << 4, r = g_pieceList[f++]; r != 0;) { for (t = r - 1; g_board[t] == 0;) t--, i++; for (g_board[t] & u && i++, t = r + 1; g_board[t] == 0;) t++, i++; for (g_board[t] & u && i++, t = r + 16; g_board[t] == 0;) t += 16, i++; for (g_board[t] & u && i++, t = r - 16; g_board[t] == 0;) t -= 16, i++; g_board[t] & u && i++; r = g_pieceList[f++] } for (o += 25 * i, i = -2, f = (n | 5) << 4, r = g_pieceList[f++]; r != 0;) { for (t = r - 15; g_board[t] == 0;) t -= 15, i++; for (g_board[t] & u && i++, t = r - 17; g_board[t] == 0;) t -= 17, i++; for (g_board[t] & u && i++, t = r + 15; g_board[t] == 0;) t += 15, i++; for (g_board[t] & u && i++, t = r + 17; g_board[t] == 0;) t += 17, i++; for (g_board[t] & u && i++, t = r - 1; g_board[t] == 0;) t--, i++; for (g_board[t] & u && i++, t = r + 1; g_board[t] == 0;) t++, i++; for (g_board[t] & u && i++, t = r + 16; g_board[t] == 0;) t += 16, i++; for (g_board[t] & u && i++, t = r - 16; g_board[t] == 0;) t -= 16, i++; g_board[t] & u && i++; r = g_pieceList[f++] } return o + 22 * i } function Evaluate() { var t = g_baseEval, n = 0, i; return g_pieceList[pieceQueen << 4] == 0 && (n -= pieceSquareAdj[pieceKing][g_pieceList[(colorWhite | pieceKing) << 4]]), g_pieceList[(colorWhite | pieceQueen) << 4] == 0 && (n += pieceSquareAdj[pieceKing][flipTable[g_pieceList[pieceKing << 4]]]), g_pieceCount[pieceBishop] >= 2 && (n -= 500), g_pieceCount[pieceBishop | colorWhite] >= 2 && (n += 500), i = Mobility(8) - Mobility(0), g_toMove == 0 ? (t -= i, t -= n) : (t += i, t += n), t } function ScoreMove(n) { var i = n >> 8 & 255, r = g_board[i] & 7, u = g_board[n & 255], t, f; return r != 0 ? (f = u & 7, t = (r << 5) - f) : t = historyTable[u & 15][i], t } function QSearch(n, t, i) { var f, l, a, r, o, h, v, y, s; if (g_qNodeCount++, f = g_inCheck ? minEval + 1 : Evaluate(), f >= t) return f; f > n && (n = f); var u = [], e = [], c = g_inCheck; if (c) for (GenerateCaptureMoves(u, null), GenerateAllMoves(u), r = 0; r < u.length; r++) e[r] = ScoreMove(u[r]); else for (GenerateCaptureMoves(u, null), r = 0; r < u.length; r++) l = g_board[u[r] >> 8 & 255] & 7, a = g_board[u[r] & 255] & 7, e[r] = (l << 5) - a; for (r = 0; r < u.length; r++) { for (o = r, h = u.length - 1; h > r; h--) e[h] > e[o] && (o = h); if ((v = u[r], u[r] = u[o], u[o] = v, y = e[r], e[r] = e[o], e[o] = y, c || See(u[r])) && MakeMove(u[r]) && (s = -QSearch(-t, -n, i - 1), UnmakeMove(u[r]), s > f)) { if (s >= t) return s; s > n && (n = s); f = s } } return f } function StoreHash(n, t, i, r, u) { n >= maxMateBuffer ? n += u : n <= minMateBuffer && (n -= u); g_hashTable[g_hashKeyLow & g_hashMask] = new HashEntry(g_hashKeyHigh, n, t, i, r) } function IsHashMoveValid(n) { var r = n & 255, i = n >> 8 & 255, e = g_board[r], f = e & 7, t, u; if (f < piecePawn || f > pieceKing || g_toMove != (e & 8) || g_board[i] != 0 && g_toMove == (g_board[i] & 8)) return !1; if (f == piecePawn) { if (n & moveflagEPC || (t = i - r, g_toMove == colorWhite != t < 0) || (u = i & 240, (u == 144 && !g_toMove || u == 32 && g_toMove) != (n & moveflagPromotion))) return !1; if (t == -16 || t == 16) return g_board[i] == 0; if (t == -15 || t == -17 || t == 15 || t == 17) return g_board[i] != 0; if (t == -32) { if (u != 96 || g_board[i] != 0 || g_board[r - 16] != 0) return !1 } else if (t == 32) { if (u != 80 || g_board[i] != 0 || g_board[r + 16] != 0) return !1 } else return !1; return !0 } return n >> 16 ? !1 : IsSquareAttackableFrom(i, r) } function IsRepDraw() { for (var n = g_moveCount - 1 - g_move50, n = n < 0 ? 0 : n, t = g_moveCount - 5; t >= n; t -= 2) if (g_repMoveStack[t] == g_hashKeyLow) return !0; return !1 } function MovePicker(n, t, i, r) { this.hashMove = n; this.depth = t; this.killer1 = i; this.killer2 = r; this.moves = []; this.losingCaptures = null; this.moveCount = 0; this.atMove = -1; this.moveScores = null; this.stage = 0; this.nextMove = function () { var f, e, t, i, u, o, s, r; if (++this.atMove == this.moveCount) { if (this.stage++, this.stage == 1 && (this.hashMove != null && IsHashMoveValid(n) && (this.moves[0] = n, this.moveCount = 1), this.moveCount != 1 && (this.hashMove = null, this.stage++)), this.stage == 2) { for (GenerateCaptureMoves(this.moves, null), this.moveCount = this.moves.length, this.moveScores = new Array(this.moveCount), t = this.atMove; t < this.moveCount; t++) f = g_board[this.moves[t] >> 8 & 255] & 7, e = g_board[this.moves[t] & 255] & 7, this.moveScores[t] = (f << 5) - e; this.atMove == this.moveCount && this.stage++ } if (this.stage == 3 && (IsHashMoveValid(this.killer1) && this.killer1 != this.hashMove ? (this.moves[this.moves.length] = this.killer1, this.moveCount = this.moves.length) : (this.killer1 = 0, this.stage++)), this.stage == 4 && (IsHashMoveValid(this.killer2) && this.killer2 != this.hashMove ? (this.moves[this.moves.length] = this.killer2, this.moveCount = this.moves.length) : (this.killer2 = 0, this.stage++)), this.stage == 5) { for (GenerateAllMoves(this.moves), this.moveCount = this.moves.length, t = this.atMove; t < this.moveCount; t++) this.moveScores[t] = ScoreMove(this.moves[t]); this.atMove == this.moveCount && this.stage++ } if (this.stage == 6) { if (this.losingCaptures != null) { for (t = 0; t < this.losingCaptures.length; t++) this.moves[this.moves.length] = this.losingCaptures[t]; for (t = this.atMove; t < this.moveCount; t++) this.moveScores[t] = ScoreMove(this.moves[t]); this.moveCount = this.moves.length } this.atMove == this.moveCount && this.stage++ } if (this.stage == 7) return 0 } for (i = this.atMove, u = this.atMove + 1; u < this.moveCount; u++) this.moveScores[u] > this.moveScores[i] && (i = u); return (i != this.atMove && (o = this.moves[this.atMove], this.moves[this.atMove] = this.moves[i], this.moves[i] = o, s = this.moveScores[this.atMove], this.moveScores[this.atMove] = this.moveScores[i], this.moveScores[i] = s), r = this.moves[this.atMove], this.stage > 1 && r == this.hashMove || this.stage > 3 && r == this.killer1 || this.stage > 4 && r == this.killer2) ? this.nextMove() : this.stage == 2 && !See(r) ? (this.losingCaptures == null && (this.losingCaptures = []), this.losingCaptures[this.losingCaptures.length] = r, this.nextMove()) : this.moves[this.atMove] } } function AllCutNode(n, t, i, r) { var s, e, o, p, c, w, b, f, v, u, k, g, h, y; if (n <= 0) return QSearch(i - 1, i, 0); if ((g_nodeCount & 127) == 127 && (new Date).getTime() - g_startTime > g_timeout) return g_searchValid = !1, i - 1; if (g_nodeCount++, IsRepDraw()) return 0; if (minEval + t >= i) return i; if (maxEval - (t + 1) < i) return i - 1; if (s = null, e = g_hashTable[g_hashKeyLow & g_hashMask], e != null && e.lock == g_hashKeyHigh && (s = e.bestMove, e.hashDepth >= n && ((o = e.value, o >= maxMateBuffer ? o -= t : o <= minMateBuffer && (o += t), e.flags == hashflagExact) || e.flags == hashflagAlpha && o < i || e.flags == hashflagBeta && o >= i))) return o; if (!g_inCheck && r && i > minMateBuffer && i < maxMateBuffer) { if (s == null && n < 4 && (p = 2500 + 200 * n, g_baseEval < i - p && (c = i - p, w = QSearch(c - 1, c, 0), w < c))) return w; if (n > 1 && g_baseEval >= i - (n >= 4 ? 2500 : 0) && (g_pieceCount[pieceBishop | g_toMove] != 0 || g_pieceCount[pieceKnight | g_toMove] != 0 || g_pieceCount[pieceRook | g_toMove] != 0 || g_pieceCount[pieceQueen | g_toMove] != 0) && (b = 3 + (n >= 5 ? 1 : n / 4), g_baseEval - i > 1500 && b++, g_toMove = 8 - g_toMove, g_baseEval = -g_baseEval, g_hashKeyLow ^= g_zobristBlackLow, g_hashKeyHigh ^= g_zobristBlackHigh, u = -AllCutNode(n - b, t + 1, -(i - 1), !1), g_hashKeyLow ^= g_zobristBlackLow, g_hashKeyHigh ^= g_zobristBlackHigh, g_toMove = 8 - g_toMove, g_baseEval = -g_baseEval, u >= i)) return i } for (var d = !1, l = minEval - 1, nt = g_inCheck, a = new MovePicker(s, t, g_killers[t][0], g_killers[t][1]) ; ;) { if (f = a.nextMove(), f == 0) break; if (v = n - 1, MakeMove(f)) { if (k = !0, g_inCheck ? v++ : (g = v - (a.atMove > 14 ? 2 : 1), a.stage == 5 && a.atMove > 5 && n >= 3 && (u = -AllCutNode(g, t + 1, -(i - 1), !0), k = u >= i)), k && (u = -AllCutNode(v, t + 1, -(i - 1), !0)), d = !0, UnmakeMove(f), !g_searchValid) return i - 1; if (u > l) { if (u >= i) return h = f >> 8 & 255, g_board[h] == 0 && (y = g_board[f & 255] & 15, historyTable[y][h] += n * n, historyTable[y][h] > 32767 && (historyTable[y][h] >>= 1), g_killers[t][0] != f && (g_killers[t][1] = g_killers[t][0], g_killers[t][0] = f)), StoreHash(u, hashflagBeta, n, f, t), u; l = u; s = f } } } return d ? (StoreHash(l, hashflagAlpha, n, s, t), l) : g_inCheck ? minEval + t : 0 } function AlphaBeta(n, t, i, r) { var v, f, e, u, o, c; if (n <= 0) return QSearch(i, r, 0); if (g_nodeCount++, t > 0 && IsRepDraw()) return 0; if (v = i, i = i < minEval + t ? i : minEval + t, r = r > maxEval - (t + 1) ? r : maxEval - (t + 1), i >= r) return i; var s = null, y = hashflagAlpha, l = g_hashTable[g_hashKeyLow & g_hashMask]; l != null && l.lock == g_hashKeyHigh && (s = l.bestMove); for (var p = g_inCheck, a = !1, h = minEval, w = new MovePicker(s, t, g_killers[t][0], g_killers[t][1]) ; ;) { if (f = w.nextMove(), f == 0) break; if (e = n - 1, MakeMove(f)) { if (g_inCheck && e++, a ? (u = -AllCutNode(e, t + 1, -i, !0), u > i && (u = -AlphaBeta(e, t + 1, -r, -i))) : u = -AlphaBeta(e, t + 1, -r, -i), a = !0, UnmakeMove(f), !g_searchValid) return i; if (u > h) { if (u >= r) return o = f >> 8 & 255, g_board[o] == 0 && (c = g_board[f & 255] & 15, historyTable[c][o] += n * n, historyTable[c][o] > 32767 && (historyTable[c][o] >>= 1), g_killers[t][0] != f && (g_killers[t][1] = g_killers[t][0], g_killers[t][0] = f)), StoreHash(u, hashflagBeta, n, f, t), u; u > v && (y = hashflagExact, i = u); h = u; s = f } } } return a ? (StoreHash(h, y, n, s, t), h) : p ? minEval + t : 0 } function MT() { var n = 624, t = 397, i = [0, 2567483615]; this.mt = new Array(n); this.mti = n + 1; this.setSeed = function () { var r = arguments, u, i, o, t; switch (r.length) { case 1: if (r[0].constructor === Number) { for (this.mt[0] = r[0], t = 1; t < n; ++t) i = this.mt[t - 1] ^ this.mt[t - 1] >>> 30, this.mt[t] = (1812433253 * ((i & 4294901760) >>> 16) << 16) + 1812433253 * (i & 65535) + t; this.mti = n; return } this.setSeed(19650218); var e = r[0].length, t = 1, f = 0; for (u = n > e ? n : e; u != 0; --u) i = this.mt[t - 1] ^ this.mt[t - 1] >>> 30, this.mt[t] = (this.mt[t] ^ (1664525 * ((i & 4294901760) >>> 16) << 16) + 1664525 * (i & 65535)) + r[0][f] + f, ++t >= n && (this.mt[0] = this.mt[n - 1], t = 1), ++f >= e && (f = 0); for (u = n - 1; u != 0; --u) i = this.mt[t - 1] ^ this.mt[t - 1] >>> 30, this.mt[t] = (this.mt[t] ^ (1566083941 * ((i & 4294901760) >>> 16) << 16) + 1566083941 * (i & 65535)) - t, ++t >= n && (this.mt[0] = this.mt[n - 1], t = 1); this.mt[0] = 2147483648; return; default: for (o = [], t = 0; t < r.length; ++t) o.push(r[t]); this.setSeed(o); return } }; this.setSeed(464384013); this.next = function (r) { var f, u, e; if (this.mti >= n) { for (f = 0, u = 0; u < n - t; ++u) f = this.mt[u] & 2147483648 | this.mt[u + 1] & 2147483647, this.mt[u] = this.mt[u + t] ^ f >>> 1 ^ i[f & 1]; for (u = n - t; u < n - 1; ++u) f = this.mt[u] & 2147483648 | this.mt[u + 1] & 2147483647, this.mt[u] = this.mt[u + (t - n)] ^ f >>> 1 ^ i[f & 1]; f = this.mt[n - 1] & 2147483648 | this.mt[0] & 2147483647; this.mt[n - 1] = this.mt[t - 1] ^ f >>> 1 ^ i[f & 1]; this.mti = 0 } return e = this.mt[this.mti++], e ^= e >>> 11, e ^= e << 7 & 2636928640, e ^= e << 15 & 4022730752, e ^= e >>> 18, e >>> 32 - r & 4294967295 } } function HashEntry(n, t, i, r, u) { this.lock = n; this.value = t; this.flags = i; this.hashDepth = r; this.bestMove = u } function MakeSquare(n, t) { return n + 2 << 4 | t + 4 } function MakeTable(n) { for (var u = new Array(256), t, i, r = 0; r < 256; r++) u[r] = 0; for (t = 0; t < 8; t++) for (i = 0; i < 8; i++) u[MakeSquare(t, i)] = n[t * 8 + i]; return u } function ResetGame() { var h, r, c, u, f, t, i, n, o, e, s; for (g_killers = new Array(128), n = 0; n < 128; n++) g_killers[n] = [0, 0]; for (g_hashTable = new Array(g_hashSize), n = 0; n < 32; n++) for (historyTable[n] = new Array(256), r = 0; r < 256; r++) historyTable[n][r] = 0; for (h = new MT(464384013), g_zobristLow = new Array(256), g_zobristHigh = new Array(256), n = 0; n < 256; n++) for (g_zobristLow[n] = new Array(16), g_zobristHigh[n] = new Array(16), r = 0; r < 16; r++) g_zobristLow[n][r] = h.next(32), g_zobristHigh[n][r] = h.next(32); for (g_zobristBlackLow = h.next(32), g_zobristBlackHigh = h.next(32), u = 0; u < 8; u++) for (f = 0; f < 8; f++) t = MakeSquare(u, f), flipTable[t] = MakeSquare(7 - u, f); for (pieceSquareAdj[piecePawn] = MakeTable(pawnAdj), pieceSquareAdj[pieceKnight] = MakeTable(knightAdj), pieceSquareAdj[pieceBishop] = MakeTable(bishopAdj), pieceSquareAdj[pieceRook] = MakeTable(rookAdj), pieceSquareAdj[pieceQueen] = MakeTable(emptyAdj), pieceSquareAdj[pieceKing] = MakeTable(kingAdj), c = [[], [], g_knightDeltas, g_bishopDeltas, g_rookDeltas, g_queenDeltas, g_queenDeltas], n = 0; n < 256; n++) g_vectorDelta[n] = {}, g_vectorDelta[n].delta = 0, g_vectorDelta[n].pieceMask = new Array(2), g_vectorDelta[n].pieceMask[0] = 0, g_vectorDelta[n].pieceMask[1] = 0; for (u = 0; u < 128; u += 16) for (f = 0; f < 8; f++) for (t = u | f, i = t - (t - 17) + 128, g_vectorDelta[i].pieceMask[colorWhite >> 3] |= 1 << piecePawn, i = t - (t - 15) + 128, g_vectorDelta[i].pieceMask[colorWhite >> 3] |= 1 << piecePawn, i = t - (t + 17) + 128, g_vectorDelta[i].pieceMask[0] |= 1 << piecePawn, i = t - (t + 15) + 128, g_vectorDelta[i].pieceMask[0] |= 1 << piecePawn, n = pieceKnight; n <= pieceKing; n++) for (o = 0; o < c[n].length; o++) for (e = t + c[n][o]; !(e & 136) ;) { if (i = t - e + 128, g_vectorDelta[i].pieceMask[colorWhite >> 3] |= 1 << n, g_vectorDelta[i].pieceMask[0] |= 1 << n, s = -1, t < e && (s = 1), (t & 240) == (e & 240) ? g_vectorDelta[i].delta = s * 1 : (t & 15) == (e & 15) ? g_vectorDelta[i].delta = s * 16 : t % 15 == e % 15 ? g_vectorDelta[i].delta = s * 15 : t % 17 == e % 17 && (g_vectorDelta[i].delta = s * 17), n == pieceKnight) { g_vectorDelta[i].delta = c[n][o]; break } if (n == pieceKing) break; e += c[n][o] } InitializeEval(); InitializeFromFen("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1") } function InitializeEval() { var n, t, i; for (g_mobUnit = new Array(2), n = 0; n < 2; n++) g_mobUnit[n] = [], t = n == 0 ? 16 : 8, i = n == 0 ? 8 : 16, g_mobUnit[n][0] = 1, g_mobUnit[n][128] = 0, g_mobUnit[n][t | piecePawn] = 1, g_mobUnit[n][t | pieceBishop] = 2, g_mobUnit[n][t | pieceKnight] = 2, g_mobUnit[n][t | pieceRook] = 4, g_mobUnit[n][t | pieceQueen] = 6, g_mobUnit[n][t | pieceKing] = 6, g_mobUnit[n][i | piecePawn] = 0, g_mobUnit[n][i | pieceBishop] = 0, g_mobUnit[n][i | pieceKnight] = 0, g_mobUnit[n][i | pieceRook] = 0, g_mobUnit[n][i | pieceQueen] = 0, g_mobUnit[n][i | pieceKing] = 0 } function SetHash() { var n = {}, t, i; for (n.hashKeyLow = 0, n.hashKeyHigh = 0, t = 0; t < 256; t++) i = g_board[t], i & 24 && (n.hashKeyLow ^= g_zobristLow[t][i & 15], n.hashKeyHigh ^= g_zobristHigh[t][i & 15]); return g_toMove || (n.hashKeyLow ^= g_zobristBlackLow, n.hashKeyHigh ^= g_zobristBlackHigh), n } function InitializeFromFen(n) { for (var i = n.split(" "), r, s, h, f, c, u, e, l, t = 0; t < 256; t++) g_board[t] = 128; var e = 0, u = 0, o = i[0]; for (t = 0; t < o.length; t++) if (r = o.charAt(t), r == "/") e++, u = 0; else if (r >= "0" && r <= "9") for (s = 0; s < parseInt(r) ; s++) g_board[MakeSquare(e, u)] = 0, u++; else { h = r >= "a" && r <= "z"; f = h ? colorBlack : colorWhite; h || (r = o.toLowerCase().charAt(t)); switch (r) { case "p": f |= piecePawn; break; case "b": f |= pieceBishop; break; case "n": f |= pieceKnight; break; case "r": f |= pieceRook; break; case "q": f |= pieceQueen; break; case "k": f |= pieceKing } g_board[MakeSquare(e, u)] = f; u++ } if (InitializePieceList(), g_toMove = i[1].charAt(0) == "w" ? colorWhite : 0, c = 8 - g_toMove, g_castleRights = 0, i[2].indexOf("K") != -1) { if (g_board[MakeSquare(7, 4)] != (pieceKing | colorWhite) || g_board[MakeSquare(7, 7)] != (pieceRook | colorWhite)) return "Invalid FEN: White kingside castling not allowed"; g_castleRights |= 1 } if (i[2].indexOf("Q") != -1) { if (g_board[MakeSquare(7, 4)] != (pieceKing | colorWhite) || g_board[MakeSquare(7, 0)] != (pieceRook | colorWhite)) return "Invalid FEN: White queenside castling not allowed"; g_castleRights |= 2 } if (i[2].indexOf("k") != -1) { if (g_board[MakeSquare(0, 4)] != (pieceKing | colorBlack) || g_board[MakeSquare(0, 7)] != (pieceRook | colorBlack)) return "Invalid FEN: Black kingside castling not allowed"; g_castleRights |= 4 } if (i[2].indexOf("q") != -1) { if (g_board[MakeSquare(0, 4)] != (pieceKing | colorBlack) || g_board[MakeSquare(0, 0)] != (pieceRook | colorBlack)) return "Invalid FEN: Black queenside castling not allowed"; g_castleRights |= 8 } for (g_enPassentSquare = -1, i[3].indexOf("-") == -1 && (u = i[3].charAt(0).charCodeAt() - "a".charCodeAt(), e = 8 - (i[3].charAt(1).charCodeAt() - "0".charCodeAt()), g_enPassentSquare = MakeSquare(e, u)), l = SetHash(), g_hashKeyLow = l.hashKeyLow, g_hashKeyHigh = l.hashKeyHigh, g_baseEval = 0, t = 0; t < 256; t++) g_board[t] & colorWhite ? (g_baseEval += pieceSquareAdj[g_board[t] & 7][t], g_baseEval += materialTable[g_board[t] & 7]) : g_board[t] & colorBlack && (g_baseEval -= pieceSquareAdj[g_board[t] & 7][flipTable[t]], g_baseEval -= materialTable[g_board[t] & 7]); return (g_toMove || (g_baseEval = -g_baseEval), g_move50 = 0, g_inCheck = IsSquareAttackable(g_pieceList[(g_toMove | pieceKing) << 4], c), IsSquareAttackable(g_pieceList[(c | pieceKing) << 4], g_toMove)) ? "Invalid FEN: Can capture king" : GenerateValidMoves().length == 0 ? g_inCheck ? "Checkmate" : "Stalemate" : "" } function InitializePieceList() { for (var i, t, n = 0; n < 16; n++) for (g_pieceCount[n] = 0, i = 0; i < 16; i++) g_pieceList[n << 4 | i] = 0; for (n = 0; n < 256; n++) g_pieceIndex[n] = 0, g_board[n] & (colorWhite | colorBlack) && (t = g_board[n] & 15, g_pieceList[t << 4 | g_pieceCount[t]] = n, g_pieceIndex[n] = g_pieceCount[t], g_pieceCount[t]++) } function MakeMove(n) { var e = g_toMove >> 3, a = 8 - g_toMove, o = n & 16711680, t = n >> 8 & 255, r = n & 255, v = g_board[t], u = g_board[r], f = t, i, c, s, p, y, h, l, w, b, d, k; if (o & moveflagEPC && (f = e ? t + 16 : t - 16, v = g_board[f], g_board[f] = pieceEmpty), g_moveUndoStack[g_moveCount] = new UndoHistory(g_enPassentSquare, g_castleRights, g_inCheck, g_baseEval, g_hashKeyLow, g_hashKeyHigh, g_move50, v), g_moveCount++, g_enPassentSquare = -1, o) if (o & moveflagCastleKing) { if (IsSquareAttackable(r + 1, a) || IsSquareAttackable(r + 2, a)) return g_moveCount--, !1; i = g_board[t + 1]; g_hashKeyLow ^= g_zobristLow[t + 1][i & 15]; g_hashKeyHigh ^= g_zobristHigh[t + 1][i & 15]; g_hashKeyLow ^= g_zobristLow[t - 1][i & 15]; g_hashKeyHigh ^= g_zobristHigh[t - 1][i & 15]; g_board[t - 1] = i; g_board[t + 1] = pieceEmpty; g_baseEval -= pieceSquareAdj[i & 7][e == 0 ? flipTable[t + 1] : t + 1]; g_baseEval += pieceSquareAdj[i & 7][e == 0 ? flipTable[t - 1] : t - 1]; c = g_pieceIndex[t + 1]; g_pieceIndex[t - 1] = c; g_pieceList[(i & 15) << 4 | c] = t - 1 } else if (o & moveflagCastleQueen) { if (IsSquareAttackable(r - 1, a) || IsSquareAttackable(r - 2, a)) return g_moveCount--, !1; i = g_board[t - 2]; g_hashKeyLow ^= g_zobristLow[t - 2][i & 15]; g_hashKeyHigh ^= g_zobristHigh[t - 2][i & 15]; g_hashKeyLow ^= g_zobristLow[t + 1][i & 15]; g_hashKeyHigh ^= g_zobristHigh[t + 1][i & 15]; g_board[t + 1] = i; g_board[t - 2] = pieceEmpty; g_baseEval -= pieceSquareAdj[i & 7][e == 0 ? flipTable[t - 2] : t - 2]; g_baseEval += pieceSquareAdj[i & 7][e == 0 ? flipTable[t + 1] : t + 1]; c = g_pieceIndex[t - 2]; g_pieceIndex[t + 1] = c; g_pieceList[(i & 15) << 4 | c] = t + 1 } if (v ? (s = v & 15, g_pieceCount[s]--, p = g_pieceList[s << 4 | g_pieceCount[s]], g_pieceIndex[p] = g_pieceIndex[f], g_pieceList[s << 4 | g_pieceIndex[p]] = p, g_pieceList[s << 4 | g_pieceCount[s]] = 0, g_baseEval += materialTable[v & 7], g_baseEval += pieceSquareAdj[v & 7][e ? flipTable[f] : f], g_hashKeyLow ^= g_zobristLow[f][s], g_hashKeyHigh ^= g_zobristHigh[f][s], g_move50 = 0) : (u & 7) == piecePawn && (y = t - r, y < 0 && (y = -y), y > 16 && (g_enPassentSquare = e ? t + 16 : t - 16), g_move50 = 0), g_hashKeyLow ^= g_zobristLow[r][u & 15], g_hashKeyHigh ^= g_zobristHigh[r][u & 15], g_hashKeyLow ^= g_zobristLow[t][u & 15], g_hashKeyHigh ^= g_zobristHigh[t][u & 15], g_hashKeyLow ^= g_zobristBlackLow, g_hashKeyHigh ^= g_zobristBlackHigh, g_castleRights &= g_castleRightsMask[r] & g_castleRightsMask[t], g_baseEval -= pieceSquareAdj[u & 7][e == 0 ? flipTable[r] : r], g_pieceIndex[t] = g_pieceIndex[r], g_pieceList[(u & 15) << 4 | g_pieceIndex[t]] = t, o & moveflagPromotion ? (h = u & -8, h |= o & moveflagPromoteKnight ? pieceKnight : o & moveflagPromoteQueen ? pieceQueen : o & moveflagPromoteBishop ? pieceBishop : pieceRook, g_hashKeyLow ^= g_zobristLow[t][u & 15], g_hashKeyHigh ^= g_zobristHigh[t][u & 15], g_board[t] = h, g_hashKeyLow ^= g_zobristLow[t][h & 15], g_hashKeyHigh ^= g_zobristHigh[t][h & 15], g_baseEval += pieceSquareAdj[h & 7][e == 0 ? flipTable[t] : t], g_baseEval -= materialTable[piecePawn], g_baseEval += materialTable[h & 7], l = u & 15, w = h & 15, g_pieceCount[l]--, b = g_pieceList[l << 4 | g_pieceCount[l]], g_pieceIndex[b] = g_pieceIndex[t], g_pieceList[l << 4 | g_pieceIndex[b]] = b, g_pieceList[l << 4 | g_pieceCount[l]] = 0, g_pieceIndex[t] = g_pieceCount[w], g_pieceList[w << 4 | g_pieceIndex[t]] = t, g_pieceCount[w]++) : (g_board[t] = g_board[r], g_baseEval += pieceSquareAdj[u & 7][e == 0 ? flipTable[t] : t]), g_board[r] = pieceEmpty, g_toMove = a, g_baseEval = -g_baseEval, (u & 7) == pieceKing || g_inCheck) { if (IsSquareAttackable(g_pieceList[(pieceKing | 8 - g_toMove) << 4], a)) return UnmakeMove(n), !1 } else if ((d = g_pieceList[(pieceKing | 8 - g_toMove) << 4], ExposesCheck(r, d)) || f != t && ExposesCheck(f, d)) return UnmakeMove(n), !1; return g_inCheck = !1, o <= moveflagEPC ? (k = g_pieceList[(pieceKing | g_toMove) << 4], g_inCheck = IsSquareAttackableFrom(k, t), g_inCheck || (g_inCheck = ExposesCheck(r, k), g_inCheck || f != t && (g_inCheck = ExposesCheck(f, k)))) : g_inCheck = IsSquareAttackable(g_pieceList[(pieceKing | g_toMove) << 4], 8 - g_toMove), g_repMoveStack[g_moveCount - 1] = g_hashKeyLow, g_move50++, !0 } function UnmakeMove(n) { var i, r, h, u, c, o, s; g_toMove = 8 - g_toMove; g_baseEval = -g_baseEval; g_moveCount--; g_enPassentSquare = g_moveUndoStack[g_moveCount].ep; g_castleRights = g_moveUndoStack[g_moveCount].castleRights; g_inCheck = g_moveUndoStack[g_moveCount].inCheck; g_baseEval = g_moveUndoStack[g_moveCount].baseEval; g_hashKeyLow = g_moveUndoStack[g_moveCount].hashKeyLow; g_hashKeyHigh = g_moveUndoStack[g_moveCount].hashKeyHigh; g_move50 = g_moveUndoStack[g_moveCount].move50; var v = 8 - g_toMove, y = g_toMove >> 3, p = v >> 3, e = n & 16711680, l = g_moveUndoStack[g_moveCount].captured, t = n >> 8 & 255, f = n & 255, a = g_board[t]; e && (e & moveflagCastleKing ? (i = g_board[t - 1], g_board[t + 1] = i, g_board[t - 1] = pieceEmpty, r = g_pieceIndex[t - 1], g_pieceIndex[t + 1] = r, g_pieceList[(i & 15) << 4 | r] = t + 1) : e & moveflagCastleQueen && (i = g_board[t + 1], g_board[t - 2] = i, g_board[t + 1] = pieceEmpty, r = g_pieceIndex[t + 1], g_pieceIndex[t - 2] = r, g_pieceList[(i & 15) << 4 | r] = t - 2)); e & moveflagPromotion ? (a = g_board[t] & -8 | piecePawn, g_board[f] = a, h = g_board[f] & 15, u = g_board[t] & 15, g_pieceCount[u]--, c = g_pieceList[u << 4 | g_pieceCount[u]], g_pieceIndex[c] = g_pieceIndex[t], g_pieceList[u << 4 | g_pieceIndex[c]] = c, g_pieceList[u << 4 | g_pieceCount[u]] = 0, g_pieceIndex[t] = g_pieceCount[h], g_pieceList[h << 4 | g_pieceIndex[t]] = t, g_pieceCount[h]++) : g_board[f] = g_board[t]; o = t; e & moveflagEPC && (o = g_toMove == colorWhite ? t + 16 : t - 16, g_board[t] = pieceEmpty); g_board[o] = l; g_pieceIndex[f] = g_pieceIndex[t]; g_pieceList[(a & 15) << 4 | g_pieceIndex[f]] = f; l && (s = l & 15, g_pieceIndex[o] = g_pieceCount[s], g_pieceList[s << 4 | g_pieceCount[s]] = o, g_pieceCount[s]++) } function ExposesCheck(n, t) { var f = t - n + 128, u, i, r, e; if ((g_vectorDelta[f].pieceMask[0] & 1 << pieceQueen) != 0) { for (u = g_vectorDelta[f].delta, i = t + u; g_board[i] == 0;) i += u; return (r = g_board[i], (r & (g_board[t] ^ 24) & 24) == 0) ? !1 : (e = i - t + 128, (g_vectorDelta[e].pieceMask[r >> 3 & 1] & 1 << (r & 7)) != 0) } return !1 } function IsSquareOnPieceLine(n, t) { var r = t - n + 128, i = g_board[t]; return g_vectorDelta[r].pieceMask[i >> 3 & 1] & 1 << (i & 7) ? !0 : !1 } function IsSquareAttackableFrom(n, t) { var i = t - n + 128, r = g_board[t], u; if (g_vectorDelta[i].pieceMask[r >> 3 & 1] & 1 << (r & 7)) { u = g_vectorDelta[i].delta; do if (t += u, t == n) return !0; while (g_board[t] == 0) } return !1 } function IsSquareAttackable(n, t) { var f = t ? -16 : 16, e = (t ? colorWhite : colorBlack) | 1, i, u, r; if (g_board[n - (f - 1)] == e || g_board[n - (f + 1)] == e) return !0; for (i = 2; i <= 6; i++) for (u = (t | i) << 4, r = g_pieceList[u]; r != 0;) { if (IsSquareAttackableFrom(n, r)) return !0; r = g_pieceList[++u] } return !1 } function GenerateMove(n, t) { return n | t << 8 } function GenerateMove(n, t, i) { return n | t << 8 | i } function GenerateValidMoves() { var i = [], n = [], t; for (GenerateCaptureMoves(n, null), GenerateAllMoves(n), t = n.length - 1; t >= 0; t--) MakeMove(n[t]) && (i[i.length] = n[t], UnmakeMove(n[t])); return i } function GenerateAllMoves(n) { for (var t, u, r = (g_toMove | 1) << 4, i = g_pieceList[r++]; i != 0;) GeneratePawnMoves(n, i), i = g_pieceList[r++]; for (r = (g_toMove | 2) << 4, i = g_pieceList[r++]; i != 0;) t = i + 31, g_board[t] == 0 && (n[n.length] = GenerateMove(i, t)), t = i + 33, g_board[t] == 0 && (n[n.length] = GenerateMove(i, t)), t = i + 14, g_board[t] == 0 && (n[n.length] = GenerateMove(i, t)), t = i - 14, g_board[t] == 0 && (n[n.length] = GenerateMove(i, t)), t = i - 31, g_board[t] == 0 && (n[n.length] = GenerateMove(i, t)), t = i - 33, g_board[t] == 0 && (n[n.length] = GenerateMove(i, t)), t = i + 18, g_board[t] == 0 && (n[n.length] = GenerateMove(i, t)), t = i - 18, g_board[t] == 0 && (n[n.length] = GenerateMove(i, t)), i = g_pieceList[r++]; for (r = (g_toMove | 3) << 4, i = g_pieceList[r++]; i != 0;) { for (t = i - 15; g_board[t] == 0;) n[n.length] = GenerateMove(i, t), t -= 15; for (t = i - 17; g_board[t] == 0;) n[n.length] = GenerateMove(i, t), t -= 17; for (t = i + 15; g_board[t] == 0;) n[n.length] = GenerateMove(i, t), t += 15; for (t = i + 17; g_board[t] == 0;) n[n.length] = GenerateMove(i, t), t += 17; i = g_pieceList[r++] } for (r = (g_toMove | 4) << 4, i = g_pieceList[r++]; i != 0;) { for (t = i - 1; g_board[t] == 0;) n[n.length] = GenerateMove(i, t), t--; for (t = i + 1; g_board[t] == 0;) n[n.length] = GenerateMove(i, t), t++; for (t = i + 16; g_board[t] == 0;) n[n.length] = GenerateMove(i, t), t += 16; for (t = i - 16; g_board[t] == 0;) n[n.length] = GenerateMove(i, t), t -= 16; i = g_pieceList[r++] } for (r = (g_toMove | 5) << 4, i = g_pieceList[r++]; i != 0;) { for (t = i - 15; g_board[t] == 0;) n[n.length] = GenerateMove(i, t), t -= 15; for (t = i - 17; g_board[t] == 0;) n[n.length] = GenerateMove(i, t), t -= 17; for (t = i + 15; g_board[t] == 0;) n[n.length] = GenerateMove(i, t), t += 15; for (t = i + 17; g_board[t] == 0;) n[n.length] = GenerateMove(i, t), t += 17; for (t = i - 1; g_board[t] == 0;) n[n.length] = GenerateMove(i, t), t--; for (t = i + 1; g_board[t] == 0;) n[n.length] = GenerateMove(i, t), t++; for (t = i + 16; g_board[t] == 0;) n[n.length] = GenerateMove(i, t), t += 16; for (t = i - 16; g_board[t] == 0;) n[n.length] = GenerateMove(i, t), t -= 16; i = g_pieceList[r++] } r = (g_toMove | 6) << 4; i = g_pieceList[r]; t = i - 15; g_board[t] == 0 && (n[n.length] = GenerateMove(i, t)); t = i - 17; g_board[t] == 0 && (n[n.length] = GenerateMove(i, t)); t = i + 15; g_board[t] == 0 && (n[n.length] = GenerateMove(i, t)); t = i + 17; g_board[t] == 0 && (n[n.length] = GenerateMove(i, t)); t = i - 1; g_board[t] == 0 && (n[n.length] = GenerateMove(i, t)); t = i + 1; g_board[t] == 0 && (n[n.length] = GenerateMove(i, t)); t = i - 16; g_board[t] == 0 && (n[n.length] = GenerateMove(i, t)); t = i + 16; g_board[t] == 0 && (n[n.length] = GenerateMove(i, t)); g_inCheck || (u = g_castleRights, g_toMove || (u >>= 2), u & 1 && g_board[i + 1] == pieceEmpty && g_board[i + 2] == pieceEmpty && (n[n.length] = GenerateMove(i, i + 2, moveflagCastleKing)), u & 2 && g_board[i - 1] == pieceEmpty && g_board[i - 2] == pieceEmpty && g_board[i - 3] == pieceEmpty && (n[n.length] = GenerateMove(i, i - 2, moveflagCastleQueen))) } function GenerateCaptureMoves(n) { for (var t, f = g_toMove == 8 ? -16 : 16, r = g_toMove == 8 ? 16 : 8, u = (g_toMove | 1) << 4, i = g_pieceList[u++]; i != 0;) t = i + f - 1, g_board[t] & r && MovePawnTo(n, i, t), t = i + f + 1, g_board[t] & r && MovePawnTo(n, i, t), i = g_pieceList[u++]; if (g_enPassentSquare != -1) { var f = g_toMove == colorWhite ? -16 : 16, e = g_toMove | piecePawn, i = g_enPassentSquare - (f + 1); (g_board[i] & 15) == e && (n[n.length] = GenerateMove(i, g_enPassentSquare, moveflagEPC)); i = g_enPassentSquare - (f - 1); (g_board[i] & 15) == e && (n[n.length] = GenerateMove(i, g_enPassentSquare, moveflagEPC)) } for (u = (g_toMove | 2) << 4, i = g_pieceList[u++]; i != 0;) t = i + 31, g_board[t] & r && (n[n.length] = GenerateMove(i, t)), t = i + 33, g_board[t] & r && (n[n.length] = GenerateMove(i, t)), t = i + 14, g_board[t] & r && (n[n.length] = GenerateMove(i, t)), t = i - 14, g_board[t] & r && (n[n.length] = GenerateMove(i, t)), t = i - 31, g_board[t] & r && (n[n.length] = GenerateMove(i, t)), t = i - 33, g_board[t] & r && (n[n.length] = GenerateMove(i, t)), t = i + 18, g_board[t] & r && (n[n.length] = GenerateMove(i, t)), t = i - 18, g_board[t] & r && (n[n.length] = GenerateMove(i, t)), i = g_pieceList[u++]; for (u = (g_toMove | 3) << 4, i = g_pieceList[u++]; i != 0;) { t = i; do t -= 15; while (g_board[t] == 0); g_board[t] & r && (n[n.length] = GenerateMove(i, t)); t = i; do t -= 17; while (g_board[t] == 0); g_board[t] & r && (n[n.length] = GenerateMove(i, t)); t = i; do t += 15; while (g_board[t] == 0); g_board[t] & r && (n[n.length] = GenerateMove(i, t)); t = i; do t += 17; while (g_board[t] == 0); g_board[t] & r && (n[n.length] = GenerateMove(i, t)); i = g_pieceList[u++] } for (u = (g_toMove | 4) << 4, i = g_pieceList[u++]; i != 0;) { t = i; do t--; while (g_board[t] == 0); g_board[t] & r && (n[n.length] = GenerateMove(i, t)); t = i; do t++; while (g_board[t] == 0); g_board[t] & r && (n[n.length] = GenerateMove(i, t)); t = i; do t -= 16; while (g_board[t] == 0); g_board[t] & r && (n[n.length] = GenerateMove(i, t)); t = i; do t += 16; while (g_board[t] == 0); g_board[t] & r && (n[n.length] = GenerateMove(i, t)); i = g_pieceList[u++] } for (u = (g_toMove | 5) << 4, i = g_pieceList[u++]; i != 0;) { t = i; do t -= 15; while (g_board[t] == 0); g_board[t] & r && (n[n.length] = GenerateMove(i, t)); t = i; do t -= 17; while (g_board[t] == 0); g_board[t] & r && (n[n.length] = GenerateMove(i, t)); t = i; do t += 15; while (g_board[t] == 0); g_board[t] & r && (n[n.length] = GenerateMove(i, t)); t = i; do t += 17; while (g_board[t] == 0); g_board[t] & r && (n[n.length] = GenerateMove(i, t)); t = i; do t--; while (g_board[t] == 0); g_board[t] & r && (n[n.length] = GenerateMove(i, t)); t = i; do t++; while (g_board[t] == 0); g_board[t] & r && (n[n.length] = GenerateMove(i, t)); t = i; do t -= 16; while (g_board[t] == 0); g_board[t] & r && (n[n.length] = GenerateMove(i, t)); t = i; do t += 16; while (g_board[t] == 0); g_board[t] & r && (n[n.length] = GenerateMove(i, t)); i = g_pieceList[u++] } u = (g_toMove | 6) << 4; i = g_pieceList[u]; t = i - 15; g_board[t] & r && (n[n.length] = GenerateMove(i, t)); t = i - 17; g_board[t] & r && (n[n.length] = GenerateMove(i, t)); t = i + 15; g_board[t] & r && (n[n.length] = GenerateMove(i, t)); t = i + 17; g_board[t] & r && (n[n.length] = GenerateMove(i, t)); t = i - 1; g_board[t] & r && (n[n.length] = GenerateMove(i, t)); t = i + 1; g_board[t] & r && (n[n.length] = GenerateMove(i, t)); t = i - 16; g_board[t] & r && (n[n.length] = GenerateMove(i, t)); t = i + 16; g_board[t] & r && (n[n.length] = GenerateMove(i, t)) } function MovePawnTo(n, t, i) { var r = i & 240; r == 144 || r == 32 ? (n[n.length] = GenerateMove(t, i, moveflagPromotion | moveflagPromoteQueen), n[n.length] = GenerateMove(t, i, moveflagPromotion | moveflagPromoteKnight), n[n.length] = GenerateMove(t, i, moveflagPromotion | moveflagPromoteBishop), n[n.length] = GenerateMove(t, i, moveflagPromotion)) : n[n.length] = GenerateMove(t, i, 0) } function GeneratePawnMoves(n, t) { var f = g_board[t], r = f & colorWhite, u = r == colorWhite ? -16 : 16, i = t + u; g_board[i] == 0 && (MovePawnTo(n, t, i, pieceEmpty), ((t & 240) == 48 && r != colorWhite || (t & 240) == 128 && r == colorWhite) && (i += u, g_board[i] == 0 && (n[n.length] = GenerateMove(t, i)))) } function UndoHistory(n, t, i, r, u, f, e, o) { this.ep = n; this.castleRights = t; this.inCheck = i; this.baseEval = r; this.hashKeyLow = u; this.hashKeyHigh = f; this.move50 = e; this.captured = o } function See(n) { var l = n & 255, i = n >> 8 & 255, c = g_board[l], w = g_seeValues[c & 15], b = g_seeValues[g_board[i] & 15], r, k, f, u, v, o, e, p, t, h; if (w <= b || n >> 16) return !0; var s = c & colorWhite ? colorWhite : 0, a = 8 - s, y = c & colorWhite ? -16 : 16; if ((g_board[i + y + 1] & 15) == (piecePawn | a) || (g_board[i + y - 1] & 15) == (piecePawn | a) || (r = [], k = w - b, SeeAddKnightAttacks(i, a, r), r.length != 0 && k > g_seeValues[pieceKnight])) return !1; for (g_board[l] = 0, u = pieceBishop; u <= pieceQueen; u++) if (SeeAddSliderAttacks(i, a, r, u) && k > g_seeValues[u]) return g_board[l] = c, !1; if ((g_board[i - y + 1] & 15) == (piecePawn | s) || (g_board[i - y - 1] & 15) == (piecePawn | s)) return g_board[l] = c, !0; for (SeeAddSliderAttacks(i, a, r, pieceKing), f = [], SeeAddKnightAttacks(i, s, f), u = pieceBishop; u <= pieceKing; u++) SeeAddSliderAttacks(i, s, f, u); for (g_board[l] = c, v = b - w; ;) { for (o = 1e3, e = -1, t = 0; t < r.length; t++) r[t] != 0 && (h = g_seeValues[g_board[r[t]] & 7], h < o && (o = h, e = t)); if (e == -1) return !0; if (v += o, v < 0) return !1; for (p = r[e], r[e] = 0, SeeAddXrayAttack(i, p, s, f, r), o = 1e3, e = -1, t = 0; t < f.length; t++) f[t] != 0 && (h = g_seeValues[g_board[f[t]] & 7], h < o && (o = h, e = t)); if (e == -1) return !1; if (v -= o, v >= 0) return !0; p = f[e]; f[e] = 0; SeeAddXrayAttack(i, p, s, f, r) } } function SeeAddXrayAttack(n, t, i, r, u) { var e = t - n + 128, f = -g_vectorDelta[e].delta; if (f != 0) { for (t += f; g_board[t] == 0;) t += f; g_board[t] & 24 && IsSquareOnPieceLine(n, t) && ((g_board[t] & 8) == i ? r[r.length] = t : u[u.length] = t) } } function SeeAddKnightAttacks(n, t, i) { for (var u = (t | pieceKnight) << 4, r = g_pieceList[u++]; r != 0;) IsSquareOnPieceLine(n, r) && (i[i.length] = r), r = g_pieceList[u++] } function SeeAddSliderAttacks(n, t, i, r) { for (var f = (t | r) << 4, u = g_pieceList[f++], e = !1; u != 0;) IsSquareAttackableFrom(n, u) && (i[i.length] = u, e = !0), u = g_pieceList[f++]; return e } function BuildPVMessage(n, t, i, r) { var u = g_nodeCount + g_qNodeCount; return "Ply:" + r + " Score:" + t + " Nodes:" + u + " NPS:" + (u / (i / 1e3) | 0) + " " + PVFromHash(n, 15) } function FinishPlyCallback(n, t, i, r) { postMessage("pv " + BuildPVMessage(n, t, i, r)) } function FinishMoveLocalTesting(n) { n != null && (MakeMove(n), postMessage(FormatMove(n))) } var g_debug = !0, g_timeout = 40, g_startTime, g_nodeCount, g_qNodeCount, g_searchValid, g_globalPly = 0, minEval = -2e6, maxEval = 2e6, minMateBuffer = minEval + 2e3, maxMateBuffer = maxEval - 2e3, materialTable = [0, 800, 3350, 3450, 5e3, 9750, 6e5], pawnAdj = [0, 0, 0, 0, 0, 0, 0, 0, -25, 105, 135, 270, 270, 135, 105, -25, -80, 0, 30, 176, 176, 30, 0, -80, -85, -5, 25, 175, 175, 25, -5, -85, -90, -10, 20, 125, 125, 20, -10, -90, -95, -15, 15, 75, 75, 15, -15, -95, -100, -20, 10, 70, 70, 10, -20, -100, 0, 0, 0, 0, 0, 0, 0, 0], knightAdj = [-200, -100, -50, -50, -50, -50, -100, -200, -100, 0, 0, 0, 0, 0, 0, -100, -50, 0, 60, 60, 60, 60, 0, -50, -50, 0, 30, 60, 60, 30, 0, -50, -50, 0, 30, 60, 60, 30, 0, -50, -50, 0, 30, 30, 30, 30, 0, -50, -100, 0, 0, 0, 0, 0, 0, -100, -200, -50, -25, -25, -25, -25, -50, -200], bishopAdj = [-50, -50, -25, -10, -10, -25, -50, -50, -50, -25, -10, 0, 0, -10, -25, -50, -25, -10, 0, 25, 25, 0, -10, -25, -10, 0, 25, 40, 40, 25, 0, -10, -10, 0, 25, 40, 40, 25, 0, -10, -25, -10, 0, 25, 25, 0, -10, -25, -50, -25, -10, 0, 0, -10, -25, -50, -50, -50, -25, -10, -10, -25, -50, -50], rookAdj = [-60, -30, -10, 20, 20, -10, -30, -60, 40, 70, 90, 120, 120, 90, 70, 40, -60, -30, -10, 20, 20, -10, -30, -60, -60, -30, -10, 20, 20, -10, -30, -60, -60, -30, -10, 20, 20, -10, -30, -60, -60, -30, -10, 20, 20, -10, -30, -60, -60, -30, -10, 20, 20, -10, -30, -60, -60, -30, -10, 20, 20, -10, -30, -60], kingAdj = [50, 150, -25, -125, -125, -25, 150, 50, 50, 150, -25, -125, -125, -25, 150, 50, 50, 150, -25, -125, -125, -25, 150, 50, 50, 150, -25, -125, -125, -25, 150, 50, 50, 150, -25, -125, -125, -25, 150, 50, 50, 150, -25, -125, -125, -25, 150, 50, 50, 150, -25, -125, -125, -25, 150, 50, 150, 250, 75, -25, -25, 75, 250, 150], emptyAdj = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], pieceSquareAdj = new Array(8), flipTable = new Array(256), colorBlack = 16, colorWhite = 8, pieceEmpty = 0, piecePawn = 1, pieceKnight = 2, pieceBishop = 3, pieceRook = 4, pieceQueen = 5, pieceKing = 6, g_vectorDelta = new Array(256), g_bishopDeltas = [-15, -17, 15, 17], g_knightDeltas = [31, 33, 14, -14, -31, -33, 18, -18], g_rookDeltas = [-1, 1, -16, 16], g_queenDeltas = [-1, 1, -15, 15, -17, 17, -16, 16], g_castleRightsMask = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 15, 15, 15, 3, 15, 15, 11, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 13, 15, 15, 15, 12, 15, 15, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], moveflagEPC = 131072, moveflagCastleKing = 262144, moveflagCastleQueen = 524288, moveflagPromotion = 1048576, moveflagPromoteKnight = 2097152, moveflagPromoteQueen = 4194304, moveflagPromoteBishop = 8388608, g_board = new Array(256), g_toMove, g_castleRights, g_enPassentSquare, g_baseEval, g_hashKeyLow, g_hashKeyHigh, g_inCheck, g_moveCount = 0, g_moveUndoStack = [], g_move50 = 0, g_repMoveStack = [], g_hashSize = 4194304, g_hashMask = g_hashSize - 1, g_hashTable, g_killers, historyTable = new Array(32), g_zobristLow, g_zobristHigh, g_zobristBlackLow, g_zobristBlackHigh, g_mobUnit, hashflagAlpha = 1, hashflagBeta = 2, hashflagExact = 3, g_pieceIndex = new Array(256), g_pieceList = new Array(256), g_pieceCount = new Array(16), g_seeValues = [0, 1, 3, 3, 5, 9, 900, 0, 0, 1, 3, 3, 5, 9, 900, 0], needsReset = !0; self.onmessage = function (n) { if (n.data != "go" && !needsReset || (ResetGame(), needsReset = !1, n.data != "go")) if (n.data.match("^position") == "position") { ResetGame(); var t = InitializeFromFen(n.data.substr(9, n.data.length - 9)); t.length != 0 && postMessage("message " + t) } else n.data.match("^search") == "search" ? (g_timeout = parseInt(n.data.substr(7, n.data.length - 7), 10), Search(FinishMoveLocalTesting, 99, FinishPlyCallback)) : n.data == "analyze" ? (g_timeout = 99999999999, Search(null, 99, FinishPlyCallback)) : MakeMove(GetMoveFromString(n.data)) }
